export default class IndexGenerator {
    /**
     * Will scan a source folder recursively and generate an index file in it that exports all files in the folder.
     * @param sourceFolder The root folder where the index file will be generated.
     * @param fileExtension The extension of the index file that is written.
     */
    static run(sourceFolder: string, fileExtension: 'mts'|'ts' = 'mts') {
        const rows = this.findFiles(sourceFolder)
        rows.unshift('/*\n *\tOBS: Do not edit, this file was generated by IndexGenerator.mts\n */')
        const outputFile = `${sourceFolder}/index.${fileExtension}`
        console.log(`Generated "${outputFile}" with ${rows.length} export(s).`)
        const encoder = new TextEncoder()
        Deno.writeFileSync(outputFile, encoder.encode(rows.join("\n")))
    }

    /**
     * Scan for files to generate exports for, will recursively traverse subfolders, skips index in the root.
     * @param path The folder to scan
     * @param subFolder Eventual subfolder we are traversing
     * @private
     */
    private static findFiles(path: string, subFolder: string = ''): string[] {
        if(subFolder.length > 0 && !subFolder.endsWith('/')) subFolder = `${subFolder}/`
        const files = Deno.readDirSync(path)
        const rows: string[] = []
        for(const dirEntry of files) {
            const fileName = dirEntry.name
            const filePath = `${path}/${fileName}`
            const lstat = Deno.lstatSync(filePath)
            if(lstat.isDirectory) {
                rows.push(...this.findFiles(filePath, `${subFolder}${fileName}`))
            } else {
                if(fileName.startsWith('index.')) continue
                if(!fileName.endsWith('.mts') && !fileName.endsWith('.ts')) continue
                rows.push(`export * from './${subFolder}${fileName}'`)
            }
        }
        return rows
    }
}